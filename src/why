#!/usr/bin/env lua

local fs = require('fs')
local getopt = require('getopt')
local hash = require('hash')
local io = io
local ipairs = ipairs
local mimetype = require('mimetype')
local loadfile = loadfile
local os = os
local pairs = pairs
local pcall = pcall
local print = print
local scgi = require('scgi')
local server = require('server')
local STATUS = scgi.STATUS
local string = string
local table = table
local tonumber = tonumber
local type = type

local magic = mimetype.open()

local COMMON_MIMETYPES = {
  ['.html'] = 'text/html',
  ['.htm'] = 'text/html',
  ['.css'] = 'text/css',
  ['.txt'] = 'text/plain',
  ['.jpg'] = 'image/jpeg',
  ['.jpeg'] = 'image/jpeg',
  ['.png'] = 'image/png',
  ['.gif'] = 'image/gif',
  ['.js'] = 'application/javascript'
}

local USAGE = [[Usage: why [OPTIONS] [DOCUMENT_ROOT]
A SCGI static file server

  -p The port to use (Default 8000)
  -f Filename of the config file
  -v Print version and exit
  -h Show this message and exit

Examples:
  why -p 8000 /var/www/html - Listen on port 8000 and use /var/www/html as the document root
  why -f /etc/why.lua - Use this file as Why's config]]

local VERSION = '1.0.0'
local DEFAULT_PORT = 8000

local function throw(err)
  io.stderr:write(("%s: %s\n"):format(arg[0], err))
  os.exit(1)
end

local function slurp(path)
  local file = io.open(path, 'rb')
  return file:read('*all')
end

function string:endswith(ending)
  return self:sub(-#ending) == ending
end

function table.merge(t1, t2)
  for k, v in pairs(t2) do
    t1[k] = v
  end
end

function table.contains(needle, haystack)
  for _, v in ipairs(haystack) do
    if v == needle then
      return true
    end
  end

  return false
end

local function process_request(request, files)
  local ok, headers = pcall(scgi.parse_request, request)

  if not ok then
    return scgi.build_error_response(STATUS.BAD_REQUEST)
  end

  local method = headers.REQUEST_METHOD

  if not table.contains(method, {'HEAD', 'GET', 'OPTIONS'}) then
    return scgi.build_error_response(STATUS.METHOD_NOT_ALLOWED)
  end

  if method == 'OPTIONS' then
    return scgi.build_response(STATUS.NO_CONTENT, {Allow = 'OPTIONS, HEAD, GET'})
  end

  local path = headers.DOCUMENT_ROOT .. headers.REQUEST_URI

  if not files[path] then
    return scgi.build_error_response(STATUS.NOT_FOUND)
  end

  local file = files[path]
  local content = file.content
  local etag = file.etag
  local res_headers = {
    ['Content-Type'] = file.mime,
    ['Content-Length'] = file.length,
    ETag = etag
  }

  local none_match = headers.HTTP_IF_NONE_MATCH or ''

  if none_match == etag then
    return scgi.build_response(STATUS.NOT_MODIFIED, {ETag = etag})
  end

  local accept_encoding = headers.HTTP_ACCEPT_ENCODING or {}

  for _, encoding in ipairs({'br', 'gzip'}) do
    if accept_encoding[encoding] and file[encoding] then
      res_headers['Content-Encoding'] = encoding
      res_headers['Content-Length'] = file[encoding].length
      content = file[encoding].content
      break
    end
  end

  local response = scgi.build_response(STATUS.OK, res_headers)

  if method == 'HEAD' then
    return response
  end

  return response, content
end

local function get_compressed_files(path, file)
  for algo, ext in pairs({gzip = '.gz', br = '.br'}) do
    local compressed = path .. ext
    if fs.exist(compressed) then
      local content = slurp(compressed)
      file[algo] = {
        content = content,
        length = #content
      }
    end
  end
end

local function add_file(path, ext)
  local content = slurp(path)

  local file = {
    mime = COMMON_MIMETYPES[ext] or magic:detect(path),
    length = #content,
    content = content,
    etag = ("%x"):format(hash.murmur(content))
  }

  get_compressed_files(path, file)
  return file
end

local function get_files(dir)
  local files = {}

  if not dir:endswith('/') then
    dir = dir .. '/'
  end

  for _, path in ipairs(fs.scandir(dir)) do
    if fs.is_dir(path) then
      table.merge(files, get_files(path))
    else
      local basename, ext = fs.fnparts(path)

      if not table.contains(ext, {'.gz', '.br'}) then
        local file = add_file(path, ext)
        files[path] = file

        -- If we have an index file, alias the directory to it
        if basename == 'index.html' then
          files[dir] = file
        end
      end
    end
  end

  return files
end

local function serve(document_root, port)
  print(('Loading files from %s'):format(document_root))
  local files = get_files(document_root)
  print('Files have been loaded')

  print('Listening on port ' .. port)
  server.listen(port,
    function(client)
      local ok, headers, content = pcall(process_request, client:recv(), files)

      if not ok then
        headers, content = scgi.build_error_response(STATUS.INTERNAL_SERVER_ERROR)
      end

      client:send(headers)

      if content then
        client:send(content)
      end
    end)
end

local function load_config(path)
  local func, err = loadfile(path, 't', {})

  if err then
    throw(err)
  end

  local conf = func()
  local t = type(conf)

  if t ~= 'table' then
    throw(('Invalid config file %s: Format should be a table, got %s'):format(path, t))
  end

  return conf
end

local function parse_args()
  local doc_root = nil
  local port = DEFAULT_PORT
  local conf = nil

  local args = getopt.parse('vhp:f:', function(opt, arg)
    if opt == 'h' then
      print(USAGE)
      os.exit()
    elseif opt == 'v' then
      print(VERSION)
      os.exit()
    elseif opt == 'p' then
      -- If we've been provided a config file, ignore this option
      if conf then
        return
      end

      port = tonumber(arg)
      if not port or port < 0 then
        throw(('Invalid port provided (%s)'):format(arg))
      end
    elseif opt == 'f' then
      conf = load_config(arg)

      for _, v in ipairs({'port', 'doc_root'}) do
        if not conf[v] then
          throw(('Invalid config file %s: Missing %s value'):format(arg, v))
        end
      end

      port = conf.port
      doc_root = conf.doc_root
    end
  end)

  doc_root = doc_root or args[1]

  if not doc_root then
    throw([[Missing document root argument
Try 'why -h' for more information]])
  end

  return doc_root, port
end

local function main()
  local doc_root, port = parse_args()
  serve(doc_root, port)
end

local ok, err = pcall(main)

if not ok then
  io.stderr:write(err .. "\n")
  os.exit(1)
end

